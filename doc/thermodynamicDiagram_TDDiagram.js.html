<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.6.3">
  <meta charset="utf-8">
  <title>Source: thermodynamicDiagram/TDDiagram.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: thermodynamicDiagram/TDDiagram.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/**
 * @module meteoJS/thermodynamicDiagram/tdDiagram
 */
import $ from &#x27;jquery&#x27;;
import { tempCelsiusToKelvin,
  tempKelvinToCelsius,
  potentialTempByTempAndPres } from &#x27;../calc.js&#x27;;

/**
 * Definition of the options for the constructor.
 * @typedef {Object} module:meteoJS/thermodynamicDiagram/tdDiagram~options
 * @param {boolean} visible Visibility of the thermodynamic diagram.
 * @param {undefined|integer} x Horizontal position of the thermodynamic diagram.
 * @param {undefined|integer} y Vertical position of the thermodynamic diagram.
 * @param {undefined|integer} width Width of the thermodynamic diagram.
 * @param {undefined|integer} height Height of the thermodynamic diagram.
 * @param {Object} isobars Isobars configuration.
 * @param {boolean} isobars.visible Isobars visibility.
 * @param {module:meteoJS/thermodynamicDiagram~lineStyleOptions} isobars.style
 *   Isobars ratio style.
 * @param {Object} isotherms Isotherms configuration.
 * @param {boolean} isotherms.visible Isotherms visibility.
 * @param {module:meteoJS/thermodynamicDiagram~lineStyleOptions} isotherms.style
 *   Isotherms style.
 * @param {Object} dryadiabats Dry adiabats configuration.
 * @param {boolean} dryadiabats.visible Dry adiabats visibility.
 * @param {meteoJS/thermodynamicDiagram~lineStyleOptions} dryadiabats.style
 *   Dry adiabats style.
 * @param {Object} pseudoadiabats Pseudo adiabats configuration.
 * @param {boolean} pseudoadiabats.visible Pseudo adiabats visibility.
 * @param {module:meteoJS/thermodynamicDiagram~lineStyleOptions} pseudoadiabats.style
 *   Pseudo adiabats style.
 * @param {Object} mixingratio Mixing ratio configuration.
 * @param {boolean} mixingratio.visible Mixing ratio visibility.
 * @param {module:meteoJS/thermodynamicDiagram~lineStyleOptions} mixingratio.style
 *   Mixing ratio style.
 */

/**
 * Class to draw the real thermodynamic diagram.
 * Constructed by {@link module:meteoJS/thermodynamicDiagram.ThermodynamicDiagram}.
 * 
 * Preconditions for options:
 * * x, y, width, height mustn&#x27;t be undefined.
 */
export class TDDiagram {
  
  /**
   * 
   * @param {module:meteoJS/thermodynamicDiagram.ThermodynamicDiagram} main
   * @param {module:meteoJS/thermodynamicDiagram/tdDiagram~options} options
   *   Diagram options.
   */
  constructor(main, options) {
    this.options &#x3D; $.extend(true, {
      visible: true,
      x: undefined,
      y: undefined,
      width: undefined,
      height: undefined,
      isobars: {
        highlightedLines: undefined,
        interval: undefined,
        lines: undefined,
        max: undefined,
        min: undefined,
        style: {
          color: undefined,
          width: 1,
          opacity: undefined,
          linecap: undefined,
          linejoin: undefined,
          dasharray: undefined
        },
        visible: true
      },
      isotherms: {
        highlightedLines: [tempCelsiusToKelvin(0)],
        interval: undefined,
        lines: undefined,
        max: undefined,
        min: undefined,
        style: {
          color: undefined,
          width: 1,
          opacity: undefined,
          linecap: undefined,
          linejoin: undefined,
          dasharray: undefined
        },
        visible: true
      },
      dryadiabats: {
        highlightedLines: undefined,
        interval: undefined,
        lines: undefined,
        max: undefined,
        min: undefined,
        style: {
          color: &#x27;green&#x27;,
          width: 1,
          opacity: undefined,
          linecap: undefined,
          linejoin: undefined,
          dasharray: undefined
        },
        visible: true
      },
      pseudoadiabats: {
        highlightedLines: undefined,
        interval: undefined,
        lines: undefined,
        max: undefined,
        min: undefined,
        style: {
          color: &#x27;blue&#x27;,
          width: 1,
          opacity: undefined,
          linecap: undefined,
          linejoin: undefined,
          dasharray: undefined
        },
        visible: true
      },
      mixingratio: {
        highlightedLines: undefined,
        interval: undefined,
        lines: undefined,
        max: undefined,
        min: undefined,
        style: {
          color: &#x27;red&#x27;,
          width: 1,
          opacity: undefined,
          linecap: undefined,
          linejoin: undefined,
          dasharray: undefined
        },
        visible: true
      }
    }, options);
  
    this.main &#x3D; main;
    this.cos &#x3D; main.getCoordinateSystem();
  
    // SVG-Gruppen initialisieren
    var svgNode &#x3D; main.getSVGNode().nested()
      .attr({
        x: this.options.x,
        y: this.options.y,
        width: this.cos.getWidth(),
        height: this.cos.getHeight()
      })
      .style({ overflow: &#x27;hidden&#x27; });
    this.svgGroups &#x3D; {
      border: svgNode.group(),
      isobars: svgNode.group(),
      isotherms: svgNode.group(),
      dryadiabats: svgNode.group(),
      mixingratio: svgNode.group(),
      pseudoadiabats: svgNode.group(),
      soundings: svgNode.group()
    };
    this.plotGuideLines();
  }

  getX() {
    return this.options.x;
  }
  getY() {
    return this.options.y;
  }
  getWidth() {
    return this.cos.getWidth();
  }
  getHeight() {
    return this.cos.getHeight();
  }

  /**
 * Return the visibility of the isobars.
 * @returns {boolean} Visibility of the isobars.
 */
  getIsobarsVisible() {
    return this.options.isobars.visible;
  }

  /**
 * Sets the visibility of the isobars.
 * @param {boolean} visible Visibility of the isobars.
 * @returns {module:meteoJS/thermodynamicDiagram/tdDiagram.TDDiagram} this.
 */
  setIsobarsVisible(visible) {
    this.options.isobars.visible &#x3D; visible ? true : false;
    this.plotIsobars();
    return this;
  }

  /**
 * Return the visibility of the isotherms.
 * @returns {boolean} Visibility of the isotherms.
 */
  getIsothermsVisible() {
    return this.options.isotherms.visible;
  }

  /**
 * Sets the visibility of the isotherms.
 * @param {boolean} visible Visibility of the isotherms.
 * @returns {module:meteoJS/thermodynamicDiagram/tdDiagram.TDDiagram} this.
 */
  setIsothermsVisible(visible) {
    this.options.isotherms.visible &#x3D; visible ? true : false;
    this.plotIsotherms();
    return this;
  }

  /**
 * Return the visibility of the dry adiabats.
 * @returns {boolean} Visibility of the dry adiabats.
 */
  getDryadiabatsVisible() {
    return this.options.dryadiabats.visible;
  }

  /**
 * Sets the visibility of the dry adiabats.
 * @param {boolean} visible Visibility of the dry adiabats.
 * @returns {module:meteoJS/thermodynamicDiagram/tdDiagram.TDDiagram} this.
 */
  setDryadiabatsVisible(visible) {
    this.options.dryadiabats.visible &#x3D; visible ? true : false;
    this.plotDryadiabats();
    return this;
  }

  /**
 * Return the visibility of the pseudo adiabats.
 * @returns {boolean} Visibility of the pseudo adiabats.
 */
  getPseudoadiabatsVisible() {
    return this.options.pseudoadiabats.visible;
  }

  /**
 * Sets the visibility of the pseudo adiabats.
 * @param {boolean} visible Visibility of the pseudo adiabats.
 * @returns {module:meteoJS/thermodynamicDiagram/tdDiagram.TDDiagram} this.
 */
  setPseudoadiabatsVisible(visible) {
    this.options.pseudoadiabats.visible &#x3D; visible ? true : false;
    this.plotPseudoadiabats();
    return this;
  }

  /**
 * Return the visibility of the mixing ratio.
 * @returns {boolean} Visibility of the mixing ratio.
 */
  getMixingratioVisible() {
    return this.options.mixingratio.visible;
  }

  /**
 * Sets the visibility of the mixing ratio.
 * @param {boolean} visible Visibility of the mixing ratio.
 * @returns {module:meteoJS/thermodynamicDiagram/tdDiagram.TDDiagram} this.
 */
  setMixingratioVisible(visible) {
    this.options.mixingratio.visible &#x3D; visible ? true : false;
    this.plotMixingratio();
    return this;
  }

  /**
 * @internal
 */
  plotGuideLines() {
    Object.keys(this.svgGroups).forEach(function (key) {
      if (key &#x3D;&#x3D; &#x27;soundings&#x27;)
        return;
      this.svgGroups[key].clear();
    }, this);
  
    // Rand des Diagramms
    this.svgGroups.border.clear();
    this.svgGroups.border
      .rect(this.cos.getWidth(), this.cos.getHeight())
      .attr({stroke: &#x27;black&#x27;, &#x27;stroke-width&#x27;: 1, &#x27;fill-opacity&#x27;: 0});
  
    // Hilfelinien zeichnen
    this.plotIsobars(true);
    this.plotIsotherms(true);
    this.plotDryadiabats(true);
    this.plotPseudoadiabats(true);
    this.plotMixingratio(true);
  }

  /**
 * @internal
 */
  plotIsobars(redraw) {
    var min &#x3D; this.cos.getPByXY(0, this.cos.getHeight());
    var max &#x3D; this.cos.getPByXY(0, 0);
    var delta &#x3D; max - min;
    this._plotLines(
      this.svgGroups.isobars,
      this.options.isobars,
      {
        min: min,
        max: max,
        interval: (delta &gt; 500) ? 50 : (delta &gt; 50) ? 10 : 1
      },
      function (p) {
        var y &#x3D; this.cos.getYByXP(0, p);
        return [[0, y], [this.cos.getWidth(), y]];
      },
      redraw
    );
  }

  /**
 * @internal
 */
  plotIsotherms(redraw) {
    var min &#x3D; tempKelvinToCelsius(
      this.cos.getTByXY(0, this.cos.getHeight()));
    var max &#x3D; tempKelvinToCelsius(
      this.cos.getTByXY(this.cos.getWidth(), 0));
    var delta &#x3D; max - min;
    this._plotLines(
      this.svgGroups.isotherms,
      this.options.isotherms,
      {
        min: min,
        max: max,
        interval: (delta &gt; 50) ? 5 : 1
      },
      function (T) {
        T &#x3D; tempCelsiusToKelvin(T);
        var result &#x3D; [[undefined, undefined], [undefined, undefined]];
        if (this.cos.isIsothermsVertical()) {
          result[0][1] &#x3D; 0;
          result[1][1] &#x3D; this.cos.getHeight();
          result[0][0] &#x3D; result[1][0] &#x3D; this.cos.getXByYT(result[0][1], T);
        }
        else {
          result[0][1] &#x3D; 0;
          result[0][0] &#x3D; this.cos.getXByYT(result[0][1], T);
          if (result[0][0] &amp;lt; 0)
            result[0][1] &#x3D; this.cos.getYByXT(result[0][0] &#x3D; 0, T);
          result[1][0] &#x3D; this.cos.getWidth();
          result[1][1] &#x3D; this.cos.getYByXT(result[1][0], T);
          if (result[1][1] &#x3D;&#x3D;&#x3D; undefined) {
            result[1][0] &#x3D; result[0][0];
            result[1][1] &#x3D; this.cos.getHeight();
          }
          else if (result[1][1] &gt; this.cos.getHeight()) {
            result[1][1] &#x3D; this.cos.getHeight();
            result[1][0] &#x3D; this.cos.getXByYT(result[1][1], T);
          }
        }
        return result;
      },
      redraw
    );
  }

  /**
 * @internal
 */
  plotDryadiabats(redraw) {
    this._plotLines(
      this.svgGroups.dryadiabats,
      this.options.dryadiabats,
      {
        min: tempKelvinToCelsius(
          potentialTempByTempAndPres(
            this.cos.getTByXY(0, 0),
            this.cos.getPByXY(0, 0))),
        max: tempKelvinToCelsius(
          potentialTempByTempAndPres(
            this.cos.getTByXY(this.cos.getWidth(), this.cos.getHeight()),
            this.cos.getPByXY(this.cos.getWidth(), this.cos.getHeight()))),
        interval: 10
      },
      function (T) {
        var TKelvin &#x3D; tempCelsiusToKelvin(T);
        var y0 &#x3D; 0;
        var x0 &#x3D; this.cos.getXByYPotentialTemperature(y0, TKelvin);
        if (x0 &#x3D;&#x3D;&#x3D; undefined ||
          x0 &gt; this.cos.getWidth()) {
          x0 &#x3D; this.cos.getWidth();
          y0 &#x3D; this.cos.getYByXPotentialTemperature(x0, TKelvin);
        }
        var x1 &#x3D; 0;
        var y1 &#x3D; this.cos.getYByXPotentialTemperature(x1, TKelvin);
        if (y1 &#x3D;&#x3D;&#x3D; undefined ||
          y1 &gt; this.cos.getHeight()) {
          y1 &#x3D; this.cos.getHeight();
          x1 &#x3D; this.cos.getXByYPotentialTemperature(y1, TKelvin);
        }
        if (x0 &#x3D;&#x3D;&#x3D; undefined ||
          y0 &#x3D;&#x3D;&#x3D; undefined ||
          x1 &#x3D;&#x3D;&#x3D; undefined ||
          y1 &#x3D;&#x3D;&#x3D; undefined)
          return undefined;
        if (this.cos.isDryAdiabatStraightLine()) {
          return [[x0, y0], [x1, y1]];
        }
        else {
          var points &#x3D; [[x0, y0]];
          var yInterval &#x3D; 10;
          for (var y&#x3D;y0+yInterval; y&amp;lt;y1; y+&#x3D;yInterval) {
            points.push([
              this.cos.getXByYPotentialTemperature(y, TKelvin),
              y
            ]);
          }
          points.push([x1, y1]);
          return points;
        }
      },
      redraw
    );
  }

  /**
 * @internal
 */
  plotPseudoadiabats(redraw) {
    this._plotLines(
      this.svgGroups.pseudoadiabats,
      this.options.pseudoadiabats,
      {
        lines: [-18, -5, 10, 30, 60, 110, 180]
      },
      function (thetae) {
        var thetaeKelvin &#x3D; tempCelsiusToKelvin(thetae);
        var y0 &#x3D; 0;
        var x0 &#x3D; this.cos.getXByYEquiPotTemp(y0, thetaeKelvin);
        var y1 &#x3D; this.cos.getHeight();
        var x1 &#x3D; this.cos.getXByYEquiPotTemp(y1, thetaeKelvin);
        var points &#x3D; [[x0, y0]];
        var yInterval &#x3D; 10;
        for (var y&#x3D;y0+yInterval; y&amp;lt;y1; y+&#x3D;yInterval) {
          points.push([
            this.cos.getXByYEquiPotTemp(y, thetaeKelvin),
            y
          ]);
        }
        points.push([x1, y1]);
        return points;
      },
      redraw
    );
  }

  /**
 * @internal
 */
  plotMixingratio(redraw) {
    this._plotLines(
      this.svgGroups.mixingratio,
      this.options.mixingratio,
      {
        lines: [0.01, 0.1, 1, 2, 4, 7, 10, 16, 21, 32, 40]
      },
      function (hmr) {
        var y0 &#x3D; 0;
        var x0 &#x3D; this.cos.getXByYHMR(y0, hmr);
        var y1 &#x3D; this.cos.getHeight();
        var x1 &#x3D; this.cos.getXByYHMR(y1, hmr);
        var points &#x3D; [[x0, y0]];
        var yInterval &#x3D; 10;
        for (var y&#x3D;y0+yInterval; y&amp;lt;y1; y+&#x3D;yInterval) {
          points.push([
            this.cos.getXByYHMR(y, hmr),
            y
          ]);
        }
        points.push([x1, y1]);
        return points;
      },
      redraw
    );
  }

  /**
 * @internal
 */
  _plotLines(node, options, valuesOptions, pointsFunc, redraw) {
    node.style(&#x27;display&#x27;, options.visible ? &#x27;inline&#x27; : &#x27;none&#x27;);
    if (!redraw)
      return;
    node.clear();
    var lines &#x3D; [];
    if (options.lines !&#x3D;&#x3D; undefined)
      lines &#x3D; options.lines;
    else if (options.min &#x3D;&#x3D;&#x3D; undefined &amp;amp;&amp;amp;
           options.max &#x3D;&#x3D;&#x3D; undefined &amp;amp;&amp;amp;
           options.interval &#x3D;&#x3D;&#x3D; undefined &amp;amp;&amp;amp;
           valuesOptions.lines !&#x3D;&#x3D; undefined)
      lines &#x3D; valuesOptions.lines;
    else {
      if (options.min !&#x3D;&#x3D; undefined)
        valuesOptions.min &#x3D; options.min;
      if (options.max !&#x3D;&#x3D; undefined)
        valuesOptions.max &#x3D; options.max;
      var interval &#x3D; options.interval;
      if (interval &#x3D;&#x3D;&#x3D; undefined)
        interval &#x3D; valuesOptions.interval;
      var start &#x3D; Math.ceil(valuesOptions.min/interval)*interval;
      var end &#x3D; Math.floor(valuesOptions.max/interval)*interval;
      for (var v&#x3D;start; v&amp;lt;&#x3D;end; v+&#x3D;interval) {
        lines.push(v);
      }
    }
    var highlightLineWidth &#x3D; 3;
    if (options.style.width !&#x3D;&#x3D; undefined)
      highlightLineWidth &#x3D; options.style.width+2;
    lines.forEach(function (v) {
      var points &#x3D; pointsFunc.call(this, v);
      var line &#x3D; (points.length &#x3D;&#x3D; 2) ?
        node.line(points[0][0], this.cos.getHeight()-points[0][1],
          points[1][0], this.cos.getHeight()-points[1][1])
          .stroke(options.style) :
        node.polyline(points.map(function (point) {
          point[1] &#x3D; this.cos.getHeight() - point[1];
          return point;
        }, this))
          .fill(&#x27;none&#x27;).stroke(options.style);
      if (options.highlightedLines !&#x3D;&#x3D; undefined)
        options.highlightedLines.forEach(function (vHighlight) {
          if (v &#x3D;&#x3D; vHighlight)
            line.stroke({width: highlightLineWidth});
        }, this);
    }, this);
  }

  /**
 * Adds Sounding to the thermodynamic diagram.
 * 
 * @internal
 * @param {module:meteoJS/thermodynamicDiagram/sounding.DiagramSounding} sounding Sounding object.
 */
  addSounding(sounding) {
    var group &#x3D; this.svgGroups.soundings.group();
    sounding.on(&#x27;change:visible&#x27;, function () {
      group.style(&#x27;display&#x27;, this.visible() ? &#x27;inline&#x27; : &#x27;none&#x27;);
    });
    sounding.trigger(&#x27;change:visible&#x27;);
  
    // Zeichnen
    var tempPolylines &#x3D; [];
    var dewpPolylines &#x3D; [];
    sounding.getSounding().getLevels().forEach(function (level) {
      if (level &#x3D;&#x3D;&#x3D; undefined)
        return;
      var levelData &#x3D; sounding.getSounding().getData(level);
      if (levelData.tmpk &#x3D;&#x3D;&#x3D; undefined)
        return;
      if (tempPolylines.length &#x3D;&#x3D; 0)
        tempPolylines.push([]);
      tempPolylines[tempPolylines.length-1].push([
        this.cos.getXByPT(level, levelData.tmpk),
        this.cos.getHeight()-this.cos.getYByPT(level, levelData.tmpk)
      ]);
      if (dewpPolylines.length &#x3D;&#x3D; 0)
        dewpPolylines.push([]);
      dewpPolylines[dewpPolylines.length-1].push([
        this.cos.getXByPT(level, levelData.dwpk),
        this.cos.getHeight()-this.cos.getYByPT(level, levelData.dwpk)
      ]);
    }, this);
    tempPolylines.forEach(function (polyline) {
      group.polyline(polyline)
        .fill(&#x27;none&#x27;).stroke(sounding.options.diagram.temp.style);
    }, this);
    dewpPolylines.forEach(function (polyline) {
      group.polyline(polyline)
        .fill(&#x27;none&#x27;).stroke(sounding.options.diagram.dewp.style);
    }, this);
  }

}
export default TDDiagram;</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.6.3 on April 16, 2020.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>